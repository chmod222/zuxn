const std = @import("std");
const config = @import("config");

/// Describes an operands of an instruction.
pub const Operand = struct {
    /// Describes the size of an operand, in bytes, on the stack.
    pub const StackSize = enum {
        /// Size is 8 bits if the instruction is in byte mode, otherwise 16 bits.
        auto,

        /// Size is guaranteed to be 8 bits.
        byte,

        /// Size is guaranteed to be 16 bits.
        short,
    };

    /// The name of the operand.
    name: []const u8,

    /// The size of the operand.
    size: StackSize,

    /// Create a new named operand with the given stack size.
    fn sized(comptime name: []const u8, size: StackSize) Operand {
        return Operand{
            .name = name,
            .size = size,
        };
    }

    fn replaceAuto(operand: Operand, size: StackSize) Operand {
        return Operand{
            .name = operand.name,
            .size = if (operand.size == .auto) size else operand.size,
        };
    }
};

/// The "base" opcode of an instruction, before the various modifiers are
/// applied. (which may change meaning significantly in the case of `BRK`)
pub const BaseOpcode = enum(u5) {
    /// `( -- a )` (LIT)
    /// `( cond8 -- )` (JCI)
    /// `( -- )` (BRK, JSI, JMI)
    BRK,

    /// `( a -- a+1 )
    INC,

    /// `( a -- )
    POP,

    /// `( a b -- b )
    NIP,

    /// `( a b -- b a )
    SWP,

    /// `( a b c -- b c a )
    ROT,

    /// `( a -- a a )
    DUP,

    /// `( a b -- a b a )
    OVR,

    /// `( a b -- bool8 )
    EQU,

    /// `( a b -- bool8 )
    NEQ,

    /// `( a b -- bool8 )
    GTH,

    /// `( a b -- bool8 )
    LTH,

    /// `( addr -- )
    JMP,

    /// `( cond8 addr -- )
    JCN,

    /// `( addr -- | ret16 )
    JSR,

    /// `( a -- | a )
    STH,

    /// `( addr8 -- v )`
    LDZ,

    /// `( v addr8 -- )`
    STZ,

    /// `( addr8 -- v )`
    LDR,

    /// `( v addr8 -- )`
    STR,

    /// `( addr16 -- v )`
    LDA,

    /// `( v addr16 -- )`
    STA,

    /// `( device8 -- v )`
    DEI,

    /// `( v device8 -- )`
    DEO,

    /// `( a b -- a+b )`
    ADD,

    /// `( a b -- a-b )`
    SUB,

    /// `( a b -- a*b )`
    MUL,

    /// `( a b -- a/b )`
    DIV,

    /// `( a b -- a&b )`
    AND,

    /// `( a b -- a|b )`
    ORA,

    /// `( a b -- a^b )`
    EOR,

    /// `( a shift8 -- c )`
    SFT,
};

/// This entire table *could* be generated by enumerating all possible u8s in
/// comptime and branching off the top 3 bits, but comptime generated enums
/// and structs cannot contain declarations, which are nice to have, plus this
/// doubles as a convenient u8 -> mnemonic lookup table.
pub const Opcode = enum(u8) {
    // Please don't mess up my table.
    // zig fmt: off
    BRK,    INC,    POP,    NIP,    SWP,    ROT,    DUP,    OVR,    EQU,    NEQ,    GTH,    LTH,    JMP,    JCN,    JSR,    STH,
    LDZ,    STZ,    LDR,    STR,    LDA,    STA,    DEI,    DEO,    ADD,    SUB,    MUL,    DIV,    AND,    ORA,    EOR,    SFT,
    JCI,    INC2,   POP2,   NIP2,   SWP2,   ROT2,   DUP2,   OVR2,   EQU2,   NEQ2,   GTH2,   LTH2,   JMP2,   JCN2,   JSR2,   STH2,
    LDZ2,   STZ2,   LDR2,   STR2,   LDA2,   STA2,   DEI2,   DEO2,   ADD2,   SUB2,   MUL2,   DIV2,   AND2,   ORA2,   EOR2,   SFT2,
    JMI,    INCr,   POPr,   NIPr,   SWPr,   ROTr,   DUPr,   OVRr,   EQUr,   NEQr,   GTHr,   LTHr,   JMPr,   JCNr,   JSRr,   STHr,
    LDZr,   STZr,   LDRr,   STRr,   LDAr,   STAr,   DEIr,   DEOr,   ADDr,   SUBr,   MULr,   DIVr,   ANDr,   ORAr,   EORr,   SFTr,
    JSI,    INC2r,  POP2r,  NIP2r,  SWP2r,  ROT2r,  DUP2r,  OVR2r,  EQU2r,  NEQ2r,  GTH2r,  LTH2r,  JMP2r,  JCN2r,  JSR2r,  STH2r,
    LDZ2r,  STZ2r,  LDR2r,  STR2r,  LDA2r,  STA2r,  DEI2r,  DEO2r,  ADD2r,  SUB2r,  MUL2r,  DIV2r,  AND2r,  ORA2r,  EOR2r,  SFT2r,
    LIT,    INCk,   POPk,   NIPk,   SWPk,   ROTk,   DUPk,   OVRk,   EQUk,   NEQk,   GTHk,   LTHk,   JMPk,   JCNk,   JSRk,   STHk,
    LDZk,   STZk,   LDRk,   STRk,   LDAk,   STAk,   DEIk,   DEOk,   ADDk,   SUBk,   MULk,   DIVk,   ANDk,   ORAk,   EORk,   SFTk,
    LIT2,   INC2k,  POP2k,  NIP2k,  SWP2k,  ROT2k,  DUP2k,  OVR2k,  EQU2k,  NEQ2k,  GTH2k,  LTH2k,  JMP2k,  JCN2k,  JSR2k,  STH2k,
    LDZ2k,  STZ2k,  LDR2k,  STR2k,  LDA2k,  STA2k,  DEI2k,  DEO2k,  ADD2k,  SUB2k,  MUL2k,  DIV2k,  AND2k,  ORA2k,  EOR2k,  SFT2k,
    LITr,   INCkr,  POPkr,  NIPkr,  SWPkr,  ROTkr,  DUPkr,  OVRkr,  EQUkr,  NEQkr,  GTHkr,  LTHkr,  JMPkr,  JCNkr,  JSRkr,  STHkr,
    LDZkr,  STZkr,  LDRkr,  STRkr,  LDAkr,  STAkr,  DEIkr,  DEOkr,  ADDkr,  SUBkr,  MULkr,  DIVkr,  ANDkr,  ORAkr,  EORkr,  SFTkr,
    LIT2r,  INC2kr, POP2kr, NIP2kr, SWP2kr, ROT2kr, DUP2kr, OVR2kr, EQU2kr, NEQ2kr, GTH2kr, LTH2kr, JMP2kr, JCN2kr, JSR2kr, STH2kr,
    LDZ2kr, STZ2kr, LDR2kr, STR2kr, LDA2kr, STA2kr, DEI2kr, DEO2kr, ADD2kr, SUB2kr, MUL2kr, DIV2kr, AND2kr, ORA2kr, EOR2kr, SFT2kr,
    // zig fmt: on

    pub inline fn fromByte(raw: u8) Opcode {
        return @enumFromInt(raw);
    }

    pub inline fn asByte(opcode: Opcode) u8 {
        return @intFromEnum(opcode);
    }

    pub fn mnemonic(opcode: Opcode) []const u8 {
        return @tagName(opcode);
    }

    pub inline fn baseOpcode(opcode: Opcode) BaseOpcode {
        return @enumFromInt(@intFromEnum(opcode) & 0x1f);
    }

    pub inline fn shortMode(opcode: Opcode) bool {
        return (@intFromEnum(opcode) & 0x20) > 0;
    }

    pub inline fn nativeOperandType(opcode: Opcode) type {
        return if (opcode.shortMode()) u16 else u8;
    }

    pub inline fn returnMode(opcode: Opcode) bool {
        return (@intFromEnum(opcode) & 0x40) > 0;
    }

    pub inline fn keepMode(opcode: Opcode) bool {
        return (@intFromEnum(opcode) & 0x80) > 0;
    }
};

fn readStackOperands(comptime notation: []const u8) []const Operand {
    var tokenizer = std.mem.tokenizeScalar(
        u8,
        notation,
        ' ',
    );

    var result: []const Operand = &.{};

    while (tokenizer.next()) |operand| {
        result = result ++ [1]Operand{Operand.sized(
            operand,
            if (std.mem.endsWith(u8, operand, "8"))
                .byte
            else if (std.mem.endsWith(u8, operand, "16"))
                .short
            else
                .auto,
        )};
    }

    return result;
}

fn readEffectNotationSide(
    comptime notation: []const u8,
) struct { []const Operand, []const Operand } {
    var stacks_iter = std.mem.splitScalar(
        u8,
        notation,
        '|',
    );

    const wst_notation = stacks_iter.next() orelse unreachable;

    if (stacks_iter.next()) |rst_notation| {
        return .{
            readStackOperands(wst_notation),
            readStackOperands(rst_notation),
        };
    } else {
        return .{ readStackOperands(wst_notation), &.{} };
    }
}

/// Holds information about the operands and result stack makeup for a specific
/// stack. (working or return stack)
pub const StackEffect = struct {
    /// The operands expected to reside on the given stack.
    before: []const Operand = &.{},

    /// The stack makeup after the effect has been applied. If the instruction
    /// was in keep-mode, this will not include the implicit before state that
    /// will remain on the stack.
    after: []const Operand = &.{},

    fn replaceAuto(comptime eff: StackEffect, size: Operand.StackSize) StackEffect {
        var new_before: []const Operand = &.{};
        var new_after: []const Operand = &.{};

        for (eff.before) |old_before| {
            new_before = new_before ++ [1]Operand{old_before.replaceAuto(size)};
        }

        for (eff.after) |old_after| {
            new_after = new_after ++ [1]Operand{old_after.replaceAuto(size)};
        }

        return StackEffect{
            .before = new_before,
            .after = new_after,
        };
    }
};

/// A structure describing the expected stack structures and effects of an
/// instruction. If the instruction is in keep-mode, the `before` states of
/// the stacks are implicitely prefixed to the `after` states and not duplicated
/// within them.
pub const StackEffects = struct {
    /// Effects applied to the working stack. (Adjusted for return-mode)
    working_stack: StackEffect = .{},

    /// Effects applied to the working stack. (Adjusted for return-mode)
    return_stack: StackEffect = .{},

    /// Parse the "standard" stack effect notation (e.g. `"a b | ra rb -- b | rb"`)
    /// into a structure of operands that can be visualized in a debugger.
    fn fromEffectNotation(comptime notation: []const u8) StackEffects {
        var iter = std.mem.splitSequence(
            u8,
            notation,
            "--",
        );

        const before = iter.next() orelse unreachable;
        const after = iter.next() orelse unreachable;

        const wst_in, const rst_in = readEffectNotationSide(before);
        const wst_out, const rst_out = readEffectNotationSide(after);

        return StackEffects{
            .working_stack = StackEffect{
                .before = wst_in,
                .after = wst_out,
            },
            .return_stack = StackEffect{
                .before = rst_in,
                .after = rst_out,
            },
        };
    }

    /// Returns a new structure where the input effects are prepended to the
    /// output effects, mirroring what the keep-mode does for instructions.
    fn keepInputs(eff: StackEffects) StackEffects {
        return StackEffects{
            .working_stack = StackEffect{
                .before = eff.working_stack.before,
                .after = eff.working_stack.before ++ eff.working_stack.after,
            },

            .return_stack = StackEffect{
                .before = eff.return_stack.before,
                .after = eff.return_stack.before ++ eff.return_stack.after,
            },
        };
    }

    /// Returns a new structure where the auto size operands are fixed size.
    fn replaceAuto(eff: StackEffects, size: Operand.StackSize) StackEffects {
        return StackEffects{
            .working_stack = eff.working_stack.replaceAuto(size),
            .return_stack = eff.return_stack.replaceAuto(size),
        };
    }
};

fn generateEffects() [0x100]StackEffects {
    // This is comparatively expensive, but only run during compilation of course.
    @setEvalBranchQuota(8192);

    var effects_r = [1]StackEffects{undefined} ** 0x100;

    // Skip BRK
    var raw_instruction: u8 = 0x00;

    while (raw_instruction < 0x20) : (raw_instruction += 1) {
        const instruction = Opcode.fromByte(raw_instruction);

        if (instruction.baseOpcode() == .BRK) {
            // The BRK instruction is overloaded with 3 entirely different effects
            // depending on its flags that completely change its meaning, so
            // it gets specialized here.

            // BRK
            effects_r[0x00] = StackEffects.fromEffectNotation("--");

            // JCI, JMI, JSI
            const jxi_eff = StackEffects.fromEffectNotation("addr8 --");

            effects_r[0x20] = jxi_eff;
            effects_r[0x40] = jxi_eff;
            effects_r[0x60] = jxi_eff;

            // LIT, LIT2, LITr, LIT2r
            const lit_eff = StackEffects.fromEffectNotation("-- a");

            effects_r[0x80] = lit_eff;
            effects_r[0xa0] = lit_eff;
            effects_r[0xc0] = lit_eff;
            effects_r[0xe0] = lit_eff;
        } else {
            // Determine the default stack effect of the instruction before
            // modifiers are applied.
            const default = switch (instruction.baseOpcode()) {
                .BRK => unreachable,

                .ADD => StackEffects.fromEffectNotation("a b -- a+b"),
                .SUB => StackEffects.fromEffectNotation("a b -- a-b"),
                .MUL => StackEffects.fromEffectNotation("a b -- a*b"),
                .DIV => StackEffects.fromEffectNotation("a b -- a/b"),
                .AND => StackEffects.fromEffectNotation("a b -- a&b"),
                .ORA => StackEffects.fromEffectNotation("a b -- a|b"),
                .EOR => StackEffects.fromEffectNotation("a b -- a^b"),
                .SFT => StackEffects.fromEffectNotation("a shift8 -- c"),

                .EQU, .NEQ, .LTH, .GTH => StackEffects.fromEffectNotation("a b -- bool8"),

                .DEO => StackEffects.fromEffectNotation("v device8 --"),
                .DEI => StackEffects.fromEffectNotation("device8 -- v"),

                .INC => StackEffects.fromEffectNotation("a -- a+1"),
                .SWP => StackEffects.fromEffectNotation("a b -- b a"),
                .ROT => StackEffects.fromEffectNotation("a b c -- b c a"),

                .STH => StackEffects.fromEffectNotation("a -- | a"),

                .LDZ, .LDR => StackEffects.fromEffectNotation("addr8 -- v"),
                .STZ, .STR => StackEffects.fromEffectNotation("v addr8 --"),

                .LDA => StackEffects.fromEffectNotation("addr16 -- v"),
                .STA => StackEffects.fromEffectNotation("v addr16 --"),

                .DUP => StackEffects.fromEffectNotation("a -- a a"),
                .OVR => StackEffects.fromEffectNotation("a b -- a b a"),
                .POP => StackEffects.fromEffectNotation("a --"),
                .NIP => StackEffects.fromEffectNotation("a b -- b"),

                .JMP => StackEffects.fromEffectNotation("addr -- "),
                .JCN => StackEffects.fromEffectNotation("cond8 addr -- "),
                .JSR => StackEffects.fromEffectNotation("addr -- | ret16"),
            };

            for (.{ 0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0 }) |flags|
                effects_r[flags | raw_instruction] = default;
        }
    }

    for (0.., &effects_r) |instr, *eff| {
        const instruction: Opcode = .fromByte(@truncate(instr));

        if (instruction.shortMode()) {
            eff.* = eff.replaceAuto(.short);
        } else {
            eff.* = eff.replaceAuto(.byte);
        }

        if (instruction.returnMode()) {
            std.mem.swap(
                StackEffect,
                &eff.working_stack,
                &eff.return_stack,
            );
        }

        if (instruction.keepMode()) {
            eff.* = eff.keepInputs();
        }
    }

    return effects_r;
}

pub const effects = generateEffects();
